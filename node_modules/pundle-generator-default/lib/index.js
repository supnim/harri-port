'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sourceMapToComment = require('source-map-to-comment');

var _sourceMapToComment2 = _interopRequireDefault(_sourceMapToComment);

var _pundleApi = require('pundle-api');

var _sourceMap = require('source-map');

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (0, _pundleApi.createGenerator)(function () {
  var _ref = _asyncToGenerator(function* (config, files) {
    var entry = yield Helpers.normalizeEntry(this, config);
    var wrapperContents = yield Helpers.getWrapperContents(this, config);

    var chunks = [';(function() {', wrapperContents];
    var chunksMap = new _sourceMap.SourceMapGenerator({
      skipValidation: true
    });
    var filePaths = [];

    var linesCount = Helpers.getLinesCount(chunks.join('\n')) + 1;

    for (var i = 0, length = files.length; i < length; i++) {
      var file = files[i];
      var publicPath = Helpers.getFilePath(this, config, file.filePath);
      var fileContents = '__sbPundle.registerModule("' + publicPath + '", function(__filename, __dirname, require, module, exports) {\n' + file.contents + '\n});';
      chunks.push(fileContents);
      filePaths.push(publicPath);
      var fileSourceMap = file.sourceMap;
      if (config.sourceMap && fileSourceMap) {
        var sourceMapPath = _path2.default.join('$' + config.sourceMapNamespace, _path2.default.relative(this.config.rootDirectory, file.filePath));
        Helpers.mergeSourceMap(fileSourceMap, chunksMap, 'pundle:///' + sourceMapPath, file.source, linesCount);
      }
      linesCount += Helpers.getLinesCount(fileContents);
    }

    var resolutionMap = JSON.stringify(Helpers.getImportResolutions(this, config, files));
    chunks.push('__sbPundle.registerMappings(' + resolutionMap + ')');
    for (var _i = 0, _length = entry.length; _i < _length; _i++) {
      chunks.push('__sbPundle.require(\'' + Helpers.getFilePath(this, config, entry[_i]) + '\')');
    }
    chunks.push('})();\n');

    var sourceMap = null;
    if (config.sourceMap) {
      sourceMap = chunksMap.toJSON();
      if (config.sourceMapPath === 'inline') {
        chunks.push((0, _sourceMapToComment2.default)(sourceMap));
      } else if (config.sourceMapPath) {
        chunks.push('//# sourceMappingURL=' + config.sourceMapPath);
      }
    }

    return {
      contents: chunks.join('\n'),
      sourceMap: sourceMap,
      filePaths: filePaths
    };
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}(), {
  entry: null,
  wrapper: 'normal',
  pathType: 'filePath',
  sourceMap: false,
  sourceMapPath: null,
  sourceNamespace: 'app',
  sourceMapNamespace: 'app'
});