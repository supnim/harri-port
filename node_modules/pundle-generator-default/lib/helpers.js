'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWrapperContents = exports.wrapperNormal = exports.wrapperHMR = exports.normalizeEntry = exports.numericPaths = exports.LINE_BREAK = undefined;

var normalizeEntry = exports.normalizeEntry = function () {
  var _ref = _asyncToGenerator(function* (compilation, config) {
    var entry = config.entry;
    if (!Array.isArray(entry)) {
      entry = compilation.config.entry;
    }
    entry = entry.slice();

    for (var i = 0, length = entry.length; i < length; i++) {
      var item = entry[i];
      if (!_path2.default.isAbsolute(item)) {
        entry[i] = yield compilation.resolve(item);
      }
    }

    return entry;
  });

  return function normalizeEntry(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var getWrapperContents = exports.getWrapperContents = function () {
  var _ref2 = _asyncToGenerator(function* (compilation, config) {
    var wrapper = config.wrapper;
    if (wrapper === 'normal') {
      wrapper = wrapperNormal;
    } else if (wrapper === 'hmr') {
      wrapper = wrapperHMR;
    } else if (wrapper === 'none') {
      return '';
    }
    if (!_path2.default.isAbsolute(wrapper)) {
      wrapper = yield compilation.resolve(wrapper);
    }
    var fileContents = yield compilation.config.fileSystem.readFile(wrapper);
    if (fileContents.slice(1, 11) === 'use strict') {
      return fileContents.slice(13);
    }
    return fileContents;
  });

  return function getWrapperContents(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

exports.getLinesCount = getLinesCount;
exports.getFilePath = getFilePath;
exports.getImportResolutions = getImportResolutions;
exports.mergeSourceMap = mergeSourceMap;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _slash = require('slash');

var _slash2 = _interopRequireDefault(_slash);

var _pundleApi = require('pundle-api');

var _sourceMap = require('source-map');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var LINE_BREAK = exports.LINE_BREAK = /\r\n|\n|\r/;
function getLinesCount(text) {
  return text.split(LINE_BREAK).length;
}

var nextNumericPath = 1;
var numericPaths = exports.numericPaths = new Map();
function getFilePath(compilation, config, filePath) {
  var toReturn = void 0;
  if (config.pathType === 'filePath') {
    toReturn = _path2.default.join('$' + config.sourceNamespace, _path2.default.relative(compilation.config.rootDirectory, filePath));
  } else {
    toReturn = numericPaths.get(filePath);
    if (!toReturn) {
      nextNumericPath++;
      numericPaths.set(filePath, toReturn = 'm-' + nextNumericPath);
    }
  }
  return (0, _slash2.default)(toReturn);
}

var wrapperHMR = exports.wrapperHMR = require.resolve('./wrappers/hmr');
var wrapperNormal = exports.wrapperNormal = require.resolve('./wrappers/normal');
function getImportResolutions(compilation, config, files) {
  var resolutionMap = {};

  function mergeResolutions(entry) {
    if (!entry.resolved) {
      throw new _pundleApi.MessageIssue('Error generating output, ' + entry.request + ' not resolved from ' + (entry.from || 'Source root'), 'error');
    }
    var filePath = getFilePath(compilation, config, entry.resolved);
    if (resolutionMap[filePath]) {
      resolutionMap[filePath].push(entry.id);
    } else {
      resolutionMap[filePath] = [entry.id];
    }
  }

  for (var i = 0, length = files.length; i < length; i++) {
    files[i].imports.forEach(mergeResolutions);
  }
  return resolutionMap;
}

function mergeSourceMap(sourceMap, target, filePath, sourceContents, offset) {
  var entryMap = new _sourceMap.SourceMapConsumer(sourceMap);
  for (var i = 0, length = entryMap._generatedMappings.length; i < length; i++) {
    var mapping = entryMap._generatedMappings[i];
    target.addMapping({
      source: filePath,
      original: { line: mapping.originalLine, column: mapping.originalColumn },
      generated: { line: offset + mapping.generatedLine, column: mapping.generatedColumn }
    });
  }
  target.setSourceContent(filePath, sourceContents);
}