'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.option = exports.OPTION_STRING_OPTIONAL_VARIADIC = exports.OPTION_STRING_REQUIRED_VARIADIC = exports.OPTION_STRING_OPTIONAL = exports.OPTION_STRING_REQUIRED = exports.OPTION_NAME = exports.DELIMETER = undefined;
exports.getParameterType = getParameterType;
exports.getDisplayName = getDisplayName;
exports.stringifyParameters = stringifyParameters;
exports.sortOptionAliases = sortOptionAliases;
exports.validateVariadic = validateVariadic;
exports.validateParameterPosition = validateParameterPosition;
exports.parseCommand = parseCommand;
exports.parseOption = parseOption;
exports.assertStringArray = assertStringArray;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DELIMETER = exports.DELIMETER = /,\s+|,|\s+/;
var OPTION_NAME = exports.OPTION_NAME = /^\-\-(.*)|\-(.*)$/;
var OPTION_STRING_REQUIRED = exports.OPTION_STRING_REQUIRED = /^<(\S+)>$/;
var OPTION_STRING_OPTIONAL = exports.OPTION_STRING_OPTIONAL = /^\[(\S+)\]$/;
var OPTION_STRING_REQUIRED_VARIADIC = exports.OPTION_STRING_REQUIRED_VARIADIC = /^<(\S+) *\.\.\.>$/;
var OPTION_STRING_OPTIONAL_VARIADIC = exports.OPTION_STRING_OPTIONAL_VARIADIC = /^\[(\S+) *\.\.\.\]$/;

function getParameterType(chunk) {
  var name = void 0;
  switch (true) {
    case OPTION_STRING_REQUIRED.test(chunk):
      name = OPTION_STRING_REQUIRED.exec(chunk)[1];
      return { type: 'required-string', name: name };
    case OPTION_STRING_OPTIONAL.test(chunk):
      name = OPTION_STRING_OPTIONAL.exec(chunk)[1];
      return { type: 'optional-string', name: name };
    case OPTION_STRING_REQUIRED_VARIADIC.test(chunk):
      name = OPTION_STRING_REQUIRED_VARIADIC.exec(chunk)[1];
      return { type: 'required-string-variadic', name: name };
    case OPTION_STRING_OPTIONAL_VARIADIC.test(chunk):
      name = OPTION_STRING_OPTIONAL_VARIADIC.exec(chunk)[1];
      return { type: 'optional-string-variadic', name: name };
    default:
      return null;
  }
}

function getDisplayName(argv) {
  return _path2.default.basename(argv[1] || 'node');
}

function stringifyParameters(parameters, parameterNames) {
  var toReturn = [];
  var wrappers = {
    optional: ['[', ']'],
    required: ['[', ']']
  };
  for (var i = 0, length = parameters.length; i < length; i++) {
    var fullType = parameters[i];
    if (fullType === 'bool') continue;
    var _type = parameters[i].slice(0, 8) === 'optional' ? 'optional' : 'required';
    toReturn.push('' + wrappers[_type][0] + parameterNames[i] + wrappers[_type][1]);
  }
  return toReturn;
}

function sortOptionAliases(aliases) {
  return aliases.sort(function (a, b) {
    if (a.length < b.length) {
      return -1;
    }
    if (a.length > b.length) {
      return 1;
    }
    return 0;
  });
}

function validateVariadic(parameters) {
  for (var i = 0, length = parameters.length; i < length; i++) {
    if (parameters[i] === 'required-string-variadic' || parameters[i] === 'optional-string-variadic') {
      if (i !== length) {
        return false;
      }
    }
  }
  return true;
}
function validateParameterPosition(current, last) {
  return !(~current.indexOf('required') && last && ~last.indexOf('optional'));
}

function parseCommand(givenCommand) {
  var command = [];
  var chunks = givenCommand.split(DELIMETER).filter(function (i) {
    return i;
  });
  var parameters = [];
  var parameterNames = [];
  var errorMessage = 'command \'' + givenCommand + '\' is invalid';

  for (var i = 0, length = chunks.length; i < length; i++) {
    var chunk = chunks[i].trim();
    if (i === 0) {
      // First is always command
      command = command.concat(chunk.split('.').filter(function (j) {
        return j;
      }));
    } else {
      var parameterInfo = getParameterType(chunk);
      if (parameterInfo) {
        if (!validateParameterPosition(parameterInfo.type, parameters[parameters.length - 1])) {
          throw new Error(errorMessage + ' because required parameter cannot appear after optional');
        }
        parameters.push(parameterInfo.type);
        parameterNames.push(parameterInfo.name);
      } else throw new Error(errorMessage);
    }
  }
  if (!command.length) {
    throw new Error(errorMessage);
  }
  if (!validateVariadic(parameters)) {
    throw new Error(errorMessage + ' because variadic should only appear at the end');
  }

  return {
    command: command,
    parameters: parameters,
    parameterNames: parameterNames
  };
}

function parseOption(option) {
  var aliasesDone = false;
  var chunks = option.split(DELIMETER).filter(function (i) {
    return i;
  });
  var aliases = [];
  var parameters = [];
  var parameterNames = [];
  var errorMessage = 'option \'' + option + '\' is invalid';

  for (var i = 0, length = chunks.length; i < length; i++) {
    var chunk = chunks[i].trim();
    if (!aliasesDone) {
      if (OPTION_NAME.test(chunk)) {
        var matched = OPTION_NAME.exec(chunk);
        aliases.push(matched[1] || matched[2]);
      } else {
        aliasesDone = true;
      }
    }

    if (aliasesDone) {
      var parameterInfo = getParameterType(chunk);
      if (parameterInfo) {
        if (!validateParameterPosition(parameterInfo.type, parameters[parameters.length - 1])) {
          throw new Error(errorMessage + ' because required parameter cannot appear after optional');
        }
        parameters.push(parameterInfo.type);
        parameterNames.push(parameterInfo.name);
      } else throw new Error(errorMessage);
    }
  }
  if (!aliases.length) {
    throw new Error(errorMessage);
  }
  if (!validateVariadic(parameters)) {
    throw new Error(errorMessage + ' because variadic should only appear at the end');
  }

  return {
    aliases: aliases,
    parameters: parameters.length ? parameters : ['bool'],
    parameterNames: parameterNames
  };
}

function assertStringArray(array, displayName) {
  (0, _assert2.default)(Array.isArray(array), displayName + ' must be an Array');
  for (var i = 0, length = array.length; i < length; i++) {
    (0, _assert2.default)(typeof array[i] === 'string', displayName + '[' + i + '] must be a string');
  }
}

var option = exports.option = {
  getOption: function getOption(options, givenName) {
    var matched = OPTION_NAME.exec(givenName);
    var name = matched[1] || matched[2];
    var found = options.find(function (entry) {
      return entry.aliases.find(function (i) {
        return i === name;
      });
    });
    if (found) {
      return {
        name: name,
        values: [],
        aliases: found.aliases,
        parameters: found.parameters,
        defaultValues: found.defaultValues
      };
    }
    // For unknown options
    return {
      name: name,
      values: [],
      aliases: [name],
      parameters: ['unknown'],
      defaultValues: []
    };
  },
  acceptsMore: function acceptsMore(lastOption) {
    if (!lastOption) {
      return false;
    }
    return !!(lastOption.values.length !== lastOption.parameters.length || ~lastOption.parameters[lastOption.parameters.length - 1].indexOf('variadic'));
  },
  requiresMore: function requiresMore(lastOption) {
    if (!lastOption) {
      return false;
    }
    var parameter = lastOption.parameters[0];
    if (parameter === 'unknown' || parameter === 'bool') {
      return false;
    }
    return lastOption.values.length < lastOption.parameters.filter(function (i) {
      return ~i.indexOf('required');
    }).length;
  },
  singlify: function singlify(parameters, values) {
    var parameter = parameters[0];
    if (parameters.length === 1 && (parameter === 'bool' || !~parameter.indexOf('variadic'))) {
      return values[0];
    }
    return values;
  }
};