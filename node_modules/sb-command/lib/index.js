'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cliff = require('cliff');

var _cliff2 = _interopRequireDefault(_cliff);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _camelcase = require('camelcase');

var _camelcase2 = _interopRequireDefault(_camelcase);

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Command = function () {
  function Command() {
    _classCallCheck(this, Command);

    this.options = [];
    this.commands = [];
    this.appVersion = '';
    this.descriptionText = '';
    this.defaultCallback = null;

    this.option('--help', 'Print usage information');
    this.option('--version', 'Print version information');
  }

  _createClass(Command, [{
    key: 'default',
    value: function _default(callback) {
      (0, _assert2.default)(typeof callback === 'function', 'default callback must be a function');
      this.defaultCallback = callback;
      return this;
    }
  }, {
    key: 'version',
    value: function version(_version) {
      (0, _assert2.default)(_version && typeof _version === 'string', 'version must be a string');
      this.appVersion = _version;
      return this;
    }
  }, {
    key: 'description',
    value: function description(descriptionText) {
      (0, _assert2.default)(descriptionText && typeof descriptionText === 'string', 'descriptionText must be a string');
      this.descriptionText = descriptionText;
      return this;
    }
  }, {
    key: 'command',
    value: function command(givenCommand, description) {
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      (0, _assert2.default)(typeof givenCommand === 'string', 'command must be a string');
      (0, _assert2.default)(typeof description === 'string', 'description must be a string');
      (0, _assert2.default)(!callback || typeof callback === 'function', 'callback must be a function');

      var _Helpers$parseCommand = Helpers.parseCommand(givenCommand),
          command = _Helpers$parseCommand.command,
          parameters = _Helpers$parseCommand.parameters,
          parameterNames = _Helpers$parseCommand.parameterNames;

      if (this.commands.find(function (i) {
        return i.command.join('.') === command.join('.');
      })) {
        throw new Error('parts of command \'' + givenCommand + '\' are already registered');
      }
      this.commands.push({ command: command, parameters: parameters, parameterNames: parameterNames, description: description, callback: callback });
      return this;
    }
  }, {
    key: 'option',
    value: function option(_option, description) {
      for (var _len = arguments.length, defaultValues = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        defaultValues[_key - 2] = arguments[_key];
      }

      (0, _assert2.default)(typeof _option === 'string', 'option must be a string');
      (0, _assert2.default)(typeof description === 'string', 'description must be a string');

      var _Helpers$parseOption = Helpers.parseOption(_option),
          aliases = _Helpers$parseOption.aliases,
          parameters = _Helpers$parseOption.parameters,
          parameterNames = _Helpers$parseOption.parameterNames;

      if (this.options.find(function (i) {
        return i.aliases.find(function (j) {
          return aliases.indexOf(j) !== -1;
        });
      })) {
        throw new Error('parts of option \'' + _option + '\' are already registered');
      }
      this.options.push({ aliases: aliases, parameters: parameters, parameterNames: parameterNames, description: description, defaultValues: defaultValues });
      return this;
    }
  }, {
    key: 'parse',
    value: function parse(argv) {
      var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var lastOption = null;
      var errorMessage = null;
      var rawNonOptions = [];
      var rawOptions = [];

      // NOTE: This is the option and non-option extraction from argv part
      // NOTE: We skip the first two because of the struct of process.argv
      for (var i = 2, length = argv.length; i < length; i++) {
        var chunk = argv[i];
        if (chunk.slice(0, 1) === '-') {
          if (lastOption) {
            if (Helpers.option.requiresMore(lastOption)) {
              errorMessage = 'Invalid value for option \'' + lastOption.name + '\'';
              break;
            }
            rawOptions.push(lastOption);
          }
          lastOption = Helpers.option.getOption(this.options, chunk);
        } else if (lastOption && Helpers.option.acceptsMore(lastOption)) {
          lastOption.values.push(chunk);
        } else rawNonOptions.push(chunk);
      }
      if (lastOption) {
        if (Helpers.option.requiresMore(lastOption)) {
          errorMessage = 'Invalid value for option \'' + lastOption.name + '\'';
        } else {
          rawOptions.push(lastOption);
        }
      }

      var options = {};
      for (var _i = 0, _length = this.options.length; _i < _length; _i++) {
        var option = this.options[_i];
        for (var j = 0, jlength = option.aliases.length; j < jlength; j++) {
          options[(0, _camelcase2.default)(option.aliases[j])] = Helpers.option.singlify(option.parameters, option.defaultValues);
        }
      }
      for (var _i2 = 0, _length2 = rawOptions.length; _i2 < _length2; _i2++) {
        var _option2 = rawOptions[_i2];
        var values = _option2.parameters[0] === 'bool' ? [true] : _option2.values;
        for (var _j = values.length, _jlength = _option2.defaultValues.length; _j < _jlength; _j++) {
          values[_j] = _option2.defaultValues[_j];
        }
        for (var _j2 = 0, _jlength2 = _option2.aliases.length; _j2 < _jlength2; _j2++) {
          // eslint-disable-next-line no-param-reassign
          options[(0, _camelcase2.default)(_option2.aliases[_j2])] = Helpers.option.singlify(_option2.parameters, values);
        }
      }

      var commandCallback = null;
      var commandParameters = [];

      // When there's no extra command name or the first name of the user requested command doesn't exist
      if (!rawNonOptions.length || !this.commands.find(function (c) {
        return c.command[0] === rawNonOptions[0];
      })) {
        commandCallback = this.defaultCallback;
        commandParameters = rawNonOptions;
      } else {
        var closest = void 0;
        for (var _i3 = 0, _length3 = this.commands.length; _i3 < _length3; _i3++) {
          var entry = this.commands[_i3];
          if (entry.command.join('.') === rawNonOptions.slice(0, entry.command.length).join('.')) {
            if (!closest || entry.command.length > closest.command.length) {
              closest = entry;
            }
          }
        }
        if (closest) {
          commandCallback = closest.callback;
          commandParameters = rawNonOptions.slice(closest.command.length);
          if (commandParameters.length < closest.parameters.filter(function (i) {
            return ~i.indexOf('required');
          }).length) {
            errorMessage = 'Not enough parameters for command: ' + closest.command.join('.');
          }
        }
      }

      if (soft) {
        return {
          options: options,
          callback: commandCallback,
          parameters: commandParameters,
          errorMessage: errorMessage
        };
      }

      if (errorMessage) {
        console.log('Error: ' + errorMessage);
      }
      if (!errorMessage && options.version) {
        console.log(this.appVersion);
        process.exit(0);
      }
      if (errorMessage || options.help || !commandCallback) {
        this.showHelp(Helpers.getDisplayName(argv));
        process.exit(1);
      } else {
        commandCallback.apply(null, [options].concat(commandParameters));
      }
      return null;
    }
  }, {
    key: 'showHelp',
    value: function showHelp() {
      var givenDisplayName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var displayName = givenDisplayName || Helpers.getDisplayName(process.argv);
      var chunks = ['Usage: ' + displayName + (this.commands.length ? ' [command...]' : '') + (this.options.length ? ' [options]' : '')];
      if (this.descriptionText) {
        chunks.push('');
        chunks.push(this.descriptionText);
      }
      if (this.options) {
        chunks.push('');
        chunks.push('Options:');
        var rows = [];
        for (var i = 0, length = this.options.length; i < length; i++) {
          var option = this.options[i];
          var aliases = Helpers.sortOptionAliases(option.aliases.slice()).map(function (a) {
            return a.length === 1 ? '-' + a : '--' + a;
          });
          var _parameters = Helpers.stringifyParameters(option.parameters, option.parameterNames);
          rows.push(['  ', aliases.join(', '), '  ', _parameters.join(' '), '  ', option.description]);
        }
        chunks.push(_cliff2.default.stringifyRows(rows));
      }
      if (this.commands) {
        chunks.push('');
        chunks.push('Commands:');
        var _rows = [];
        for (var _i4 = 0, _length4 = this.commands.length; _i4 < _length4; _i4++) {
          var entry = this.commands[_i4];
          var _parameters2 = Helpers.stringifyParameters(entry.parameters, entry.parameterNames);
          _rows.push(['  ', entry.command.join(' '), '  ', _parameters2, '  ', entry.description]);
        }
        chunks.push(_cliff2.default.stringifyRows(_rows));
      }
      var helpText = chunks.join('\n');
      if (!soft) {
        console.log(helpText);
      }
      return helpText;
    }
  }]);

  return Command;
}();

var command = new Command();
// $FlowIgnore: Custom property
command.Command = Command;

module.exports = command;