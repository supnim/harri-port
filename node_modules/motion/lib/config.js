'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('./fs');

var FS = _interopRequireWildcard(_fs);

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

var _error = require('./error');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Config = function () {
  function Config(config, configPath, projectPath) {
    _classCallCheck(this, Config);

    this.config = config;
    this.configPath = configPath;
    this.projectPath = projectPath;
  }

  _createClass(Config, [{
    key: 'getBundleDirectory',
    value: function getBundleDirectory() {
      return _path2.default.resolve(this.projectPath, this.get('bundleDirectory'));
    }
  }, {
    key: 'getPublicDirectory',
    value: function getPublicDirectory() {
      return _path2.default.resolve(this.projectPath, this.get('publicDirectory'));
    }
  }, {
    key: 'get',
    value: function get(key) {
      return this.config[key];
    }
  }, {
    key: 'write',
    value: function () {
      var _ref = _asyncToGenerator(function* () {
        yield FS.writeJSON(this.configPath, this.config);
      });

      function write() {
        return _ref.apply(this, arguments);
      }

      return write;
    }()
  }], [{
    key: 'create',
    value: function () {
      var _ref2 = _asyncToGenerator(function* (projectPath) {
        var config = {
          babel: {
            presets: ['babel-preset-motion']
          },
          pathType: 'filePath',
          webServerPort: Helpers.getRandomNumber(8000, 15000),
          saveNpmModules: true,
          bundleDirectory: '.',
          publicDirectory: './public'
        };
        var configPath = _path2.default.join(projectPath, '.motion.json');
        try {
          Object.assign(config, (yield FS.readJSON(configPath)));
        } catch (error) {
          if (error && error.name === 'SyntaxError') {
            throw new _error.MotionError(_error.ERROR_CODE.INVALID_MANIFEST);
          }
        }
        return new Config(config, configPath, projectPath);
      });

      function create(_x) {
        return _ref2.apply(this, arguments);
      }

      return create;
    }()
  }]);

  return Config;
}();

exports.default = Config;
//# sourceMappingURL=config.js.map