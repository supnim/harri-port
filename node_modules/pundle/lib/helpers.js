'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadables = exports.getPundleConfig = exports.resolve = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var resolve = exports.resolve = function () {
  var _ref = _asyncToGenerator(function* (request, rootDirectory) {
    var resolved = void 0;
    try {
      resolved = yield resolveModule(request, { basedir: rootDirectory });
    } catch (_) {
      var error = new Error('Unable to resolve \'' + request + '\' from root directory');
      error.code = 'MODULE_NOT_FOUND';

      error.duringResolution = true;
      throw error;
    }
    var mainModule = void 0;
    try {
      mainModule = require(resolved);
    } catch (error) {
      if (error.code === 'MODULE_NOT_FOUND') {
        var showFancyError = false;
        var stack = (0, _sbCallsite.fromStack)(error.stack);
        for (var i = 0, length = stack.length; i < length; i++) {
          var entry = stack[i];
          if (_path2.default.isAbsolute(entry.file)) {
            showFancyError = entry.file === resolved || entry.file === __dirname;
            break;
          }
        }
        if (showFancyError) {
          var chunks = MODULE_NAME_REGEXP.exec(error.message);
          if (chunks && chunks.length) {
            throw new _pundleApi.MessageIssue('Unable to load \'' + chunks[1] + '\' from root directory. Make sure it\'s installed correctly');
          }
        }
      }
      throw error;
    }
    mainModule = mainModule && mainModule.__esModule ? mainModule.default : mainModule;
    if ((typeof mainModule === 'undefined' ? 'undefined' : _typeof(mainModule)) === 'object' && mainModule) {
      return mainModule;
    }
    throw new _pundleApi.MessageIssue('Module \'' + request + '\' (at \'' + (0, _pundleApi.getRelativeFilePath)(resolved, rootDirectory) + '\') exported incorrectly');
  });

  return function resolve(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var getPundleConfig = exports.getPundleConfig = function () {
  var _ref2 = _asyncToGenerator(function* (rootDirectory, a) {
    var config = {};

    var b = {};
    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || !a) {
      throw new Error('Config must be an object');
    }
    if (typeof a.enableConfigFile === 'undefined' || a.enableConfigFile) {
      var configModule = void 0;
      try {
        configModule = yield resolve(_path2.default.join(rootDirectory, a.configFileName || '.pundle.js'), rootDirectory);
      } catch (error) {
        if (!error.duringResolution) {
          throw error;
        }
      }
      if (typeof configModule === 'function') {
        b = yield configModule();
      } else if ((typeof configModule === 'undefined' ? 'undefined' : _typeof(configModule)) === 'object') {
        b = configModule;
      }
      if (!b) {
        throw new _pundleApi.MessageIssue('Invalid export value of config file in \'' + rootDirectory + '\'');
      }
    }

    Object.assign(config, b);

    config.watcher = {};
    if (b.watcher) {
      (0, _assert2.default)(_typeof(b.watcher) === 'object', 'config.watcher must be an Object');
      Object.assign(config.watcher, b.watcher);
    }
    if (a.watcher) {
      (0, _assert2.default)(_typeof(a.watcher) === 'object', 'config.watcher must be an Object');
      Object.assign(config.watcher, a.watcher);
    }
    config.presets = [];
    if (a.presets) {
      (0, _assert2.default)(Array.isArray(a.presets), 'config.presets must be an Array');
      config.presets = config.presets.concat(a.presets);
    }
    if (b.presets) {
      (0, _assert2.default)(Array.isArray(b.presets), 'config.presets must be an Array');
      config.presets = config.presets.concat(b.presets);
    }
    config.components = [];
    if (a.components) {
      (0, _assert2.default)(Array.isArray(a.components), 'config.components must be an Array');
      config.components = config.components.concat(a.components);
    }
    if (b.components) {
      (0, _assert2.default)(Array.isArray(b.components), 'config.components must be an Array');
      config.components = config.components.concat(b.components);
    }

    var compilation = {};
    if (typeof a.debug !== 'undefined') {
      compilation.debug = !!a.debug;
    } else if (typeof b.debug !== 'undefined') {
      compilation.debug = !!b.debug;
    } else {
      compilation.debug = !process.env.NODE_ENV !== 'production';
    }
    compilation.entry = [];
    if (!a.entry && !b.entry) {
      throw new _pundleApi.MessageIssue('config.entry should be an Array or string');
    }
    if (a.entry) {
      (0, _assert2.default)(typeof a.entry === 'string' || Array.isArray(a.entry), 'config.entry must be an Array or string');
      compilation.entry = compilation.entry.concat(a.entry);
    }
    if (b.entry) {
      (0, _assert2.default)(typeof b.entry === 'string' || Array.isArray(b.entry), 'config.entry must be an Array or string');
      compilation.entry = compilation.entry.concat(b.entry);
    }
    compilation.fileSystem = Object.assign({}, _pundleFs2.default);
    if (b.fileSystem) {
      (0, _assert2.default)(_typeof(b.fileSystem) === 'object', 'config.fileSystem must be an Object');
      Object.assign(compilation.fileSystem, b.fileSystem);
    }
    if (a.fileSystem) {
      (0, _assert2.default)(_typeof(a.fileSystem) === 'object', 'config.fileSystem must be an Object');
      Object.assign(compilation.fileSystem, a.fileSystem);
    }
    if (!a.rootDirectory && !b.rootDirectory) {
      throw new _pundleApi.MessageIssue('config.rootDirectory must be a string');
    }
    if (a.rootDirectory) {
      (0, _assert2.default)(a.rootDirectory, 'config.rootDirectory must be a string');
      compilation.rootDirectory = a.rootDirectory;
    }
    if (b.rootDirectory) {
      (0, _assert2.default)(b.rootDirectory, 'config.rootDirectory must be a string');
      compilation.rootDirectory = b.rootDirectory;
    }
    compilation.replaceVariables = Object.assign({}, {
      'process.env.NODE_ENV': config.debug ? '"development"' : '"production"'
    }, config.replaceVariables);
    if (b.replaceVariables) {
      (0, _assert2.default)(_typeof(b.replaceVariables) === 'object', 'config.replaceVariables must be an Object');
      Object.assign(compilation.replaceVariables, b.replaceVariables);
    }
    if (a.replaceVariables) {
      (0, _assert2.default)(_typeof(a.replaceVariables) === 'object', 'config.replaceVariables must be an Object');
      Object.assign(compilation.replaceVariables, a.replaceVariables);
    }

    config.compilation = compilation;
    return config;
  });

  return function getPundleConfig(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

var getLoadables = exports.getLoadables = function () {
  var _ref3 = _asyncToGenerator(function* (loadables, rootDirectory) {
    var toReturn = [];
    for (var i = 0, length = loadables.length; i < length; i++) {
      var entry = loadables[i];

      var config = {};
      var component = void 0;
      if (Array.isArray(entry)) {
        var _entry = _slicedToArray(entry, 2);

        component = _entry[0];
        config = _entry[1];
      } else {
        component = entry;
      }
      var resolved = typeof component === 'string' ? yield resolve(component, rootDirectory) : component;
      if (!resolved || typeof resolved.$type !== 'string') {
        throw new _pundleApi.MessageIssue('Unable to load invalid component');
      }
      toReturn.push([resolved, config]);
    }
    return toReturn;
  });

  return function getLoadables(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
}();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _pundleFs = require('pundle-fs');

var _pundleFs2 = _interopRequireDefault(_pundleFs);

var _sbPromisify = require('sb-promisify');

var _sbPromisify2 = _interopRequireDefault(_sbPromisify);

var _sbCallsite = require('sb-callsite');

var _pundleApi = require('pundle-api');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var resolveModule = (0, _sbPromisify2.default)(require('resolve'));
var MODULE_NAME_REGEXP = /Cannot find module '(.*?)'/;