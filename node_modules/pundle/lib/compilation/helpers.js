'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.filterComponents = filterComponents;
exports.invokeComponent = invokeComponent;
exports.mergeSourceMap = mergeSourceMap;
exports.mergeResult = mergeResult;
exports.fillWatcherConfig = fillWatcherConfig;
exports.getAllKnownExtensions = getAllKnownExtensions;

var _lodash = require('lodash.uniq');

var _lodash2 = _interopRequireDefault(_lodash);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function* filterComponents(components, type) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var entry = _step.value;

      if (entry.component.$type === type) {
        yield entry;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function invokeComponent(thisArg, entry, method, configs) {
  (0, _assert2.default)(typeof entry.component[method] === 'function', 'Component method \'' + method + '\' does not exist on given component');

  for (var _len = arguments.length, givenParameters = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
    givenParameters[_key - 4] = arguments[_key];
  }

  var parameters = givenParameters.map(function (item) {
    if (item && item.constructor === Object) {
      return Object.assign({}, item);
    }
    return item;
  });
  return entry.component[method].apply(thisArg, [Object.assign.apply(Object, [{}, entry.component.defaultConfig, entry.config].concat(_toConsumableArray(configs)))].concat(parameters));
}

function mergeSourceMap(inputMap, map) {
  var inputMapConsumer = new _sourceMap2.default.SourceMapConsumer(inputMap);
  var outputMapConsumer = new _sourceMap2.default.SourceMapConsumer(map);

  var mergedGenerator = new _sourceMap2.default.SourceMapGenerator({
    file: inputMapConsumer.file,
    sourceRoot: inputMapConsumer.sourceRoot,
    skipValidation: true
  });

  var source = outputMapConsumer.sources[0];

  inputMapConsumer.eachMapping(function (mapping) {
    var generatedPosition = outputMapConsumer.generatedPositionFor({
      line: mapping.generatedLine,
      column: mapping.generatedColumn,
      source: source
    });
    if (typeof generatedPosition.column !== 'undefined') {
      mergedGenerator.addMapping({
        source: mapping.source,

        original: !mapping.source ? null : {
          line: mapping.originalLine,
          column: mapping.originalColumn
        },

        generated: generatedPosition
      });
    }
  });

  var mergedMap = mergedGenerator.toJSON();
  inputMap.mappings = mergedMap.mappings;
  return inputMap;
}

function mergeResult(file, result) {
  if (!result) {
    return;
  }
  if (file.sourceMap && !result.sourceMap) {
    file.sourceMap = null;
  } else if (file.sourceMap && result.sourceMap) {
    file.sourceMap = mergeSourceMap(file.sourceMap, result.sourceMap);
  } else if (!file.sourceMap && result.sourceMap) {
    file.sourceMap = result.sourceMap;
  }
  file.contents = result.contents;
}

function fillWatcherConfig(config) {
  var toReturn = {};

  (0, _assert2.default)((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config, 'Watcher config must be an object');
  toReturn.usePolling = typeof config.usePolling === 'undefined' ? {}.hasOwnProperty.call(process.env, 'PUNDLE_WATCHER_USE_POLLING') : !!config.usePolling;

  return toReturn;
}

function getAllKnownExtensions(components) {
  var toReturn = [''];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = components[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var entry = _step2.value;

      if (entry.component.$type === 'loader') {
        if (Array.isArray(entry.config.extensions)) {
          toReturn = toReturn.concat(entry.config.extensions);
        } else if (Array.isArray(entry.component.defaultConfig.extensions)) {
          toReturn = toReturn.concat(entry.component.defaultConfig.extensions);
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return (0, _lodash2.default)(toReturn);
}